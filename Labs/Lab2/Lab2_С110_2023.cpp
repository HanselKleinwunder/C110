/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции

*************************************************************/
#include <iostream>
#include <tchar.h>
#include <cstdio>
#include <cstdarg>
#include "other.h"
#pragma warning(disable : 4996)

#define	  stop __asm nop

int _tmain()
{
//Задание 1. 
//Массивы в качестве аргументов функции.
#if 0
//Напишите два варианта функции печати элементов
//1. Встроенного двумерного массива
//int ar[N][M]; //подумайте - как и где должны быть заданы N и M
//Замечание:
// Задать значения элементам массива можно либо с помощью списка инициализации, 
// либо с помощью кода 
//Вызов функции PrintArray может выглядеть так:
//	PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);  //Важно! первый параметр - имя двумерного (!) массива
	{
		int arr[N][M];

		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << "Enter array element for index [" << i << "][" << j << "]: ";
				std::cin >> arr[i][j];
			}
		}

		PrintArray(arr, N);
	}
	//2. динамического двумерного массива (обе размерности вычисляются)
	//Замечание:
	// Задать значения элементам массива можно с помощью кода
	{
		int N = 5, M = 6; //2 строчки, а в каждой строчке по 2 колонки

		int** arr = new int* [N]; //создали массив указателей

		for (size_t i = 0; i < N; i++)
		{
			arr[i] = new int[M]; //в каждый элемент, который будет хранить указатель, присваиваем новый динамический массив
		}

		//Заполняем массив
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << "Enter array element for index [" << i << "][" << j << "]: ";
				std::cin >> arr[i][j];
			}
		}

		PrintArray(arr, N, M);

		for (size_t i = 0; i < N; i++)
		{
			delete[] arr[i];
		}

		delete[] arr;
	}
#endif
	stop
/////////////////////////////////////////////////////////////////////////////
//Задание 2. 
//Передача имени встроенного двумерного массива в качестве параметра функции.
#if 1
//Напишите две взаимодополняющие друг друга функции:
//1.  ... DayOfYear(...)
//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
//в порядковый день года(возвращаемое значение)
//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
// (принимает год и порядковый день года в качестве параметров и должна сформировать
// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
//данные приведенного ниже двухмерного массива nDayTab
//Проверьте работоспособность обеих функций с помощью следующего фрагмента:
//Вызов функции DayOfYear может выглядеть так:

	int nDayTab[2][12] = {
	{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
	{31,29,31,30,31,30,31,31,30,31,30,31} }; //високосный год

	int day, month, year;

	std::cout << "Enter day: ";
	std::cin >> day;
	std::cout << "Enter month: ";
	std::cin >> month;
	std::cout << "Enter year: ";
	std::cin >> year;

	int dayOfYear = DayOfYear(day, month, year, nDayTab);

	if (dayOfYear == -1) {
		std::cout << std::endl;
		std::cout << "Invalid date entry!" << std::endl;
	}
	else {
		std::cout << std::endl;
		std::cout << "The " << day << "." << month << "." << year << " is the " << dayOfYear << " day of the year." << std::endl;
	}

	int dayOfMonth = DayOfMonth(day, year, nDayTab);
	const char* defineMonth = DefineMonth(day / 30 + 1);

	std::cout << "The " << dayOfMonth << " day of the " << defineMonth << std::endl;

	//size_t day = ..., month = ..., year = ...;
	//size_t numDay = DayOfYear(day, month, year, nDayTab);  //Важно! последний параметр- имя двумерного (!) массива


//Проверка результата обратной функцией DayOfMonth        //Важно! последний параметр- имя двумерного (!) массива
//...
#endif
	stop
/////////////////////////////////////////////////////////////////////////////
//Задание 3.
#if 0
	{
		//Задание 3а. Функции с переменным числом параметров.
		//Напишите функцию (дана заготовка VarArgs, не использующая
		// макросы), которая принимает переменное число аргументов
		// типа int и выводит на печать число принятых параметров и
		// их значения.
		// Признаком конца списка является нулевое значение.

		int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
		VarArgs(nN1, 0);
		VarArgs(nN1, nN2, 0);
		VarArgs(nN1, nN2, nN3, nN4, nN5, 0);

		std::cout << std::endl;
		//Задание 3б. Модифицируйте функцию 3а с помощью макросов
		// va_start, va_arg, va_end

		VarArgsMacros(nN1, 0);
		VarArgsMacros(nN1, nN2, 0);
		VarArgsMacros(nN1, nN2, nN3, nN4, nN5, 0);
		stop
	}
#endif
	stop
///////////////////////////////////////////////////////////////////
//Тема "Старые" потоковые функции стандартной библиотеки
//Задание 4.1-4.2
#if 0
//С помощью функции scanf сформируйте три коэффициента : A, B, C
	{
		int a, b, c;

		std::cout << "Enter integer for A: ";
		scanf("%i", &a);
		std::cout << "Enter integer for B: ";
		scanf("%i", &b);
		std::cout << "Enter integer for C: ";
		scanf("%i", &c);
		std::cout << std::endl;
		std::cout << "A = " << a << "\nB = " << b << "\nC = " << c << std::endl;
		std::cout << std::endl;

		//Выведите таблицу значений y = A * x * x + B * x + C
		//при изменении x в диапазоне -2 до +2 с шагом 0.5

		int counter = 0;
		for (double x = -2.01; x < 2.0; x += 0.5) {
			counter++;
			printf("| %2d|%4.1lf|  %6.1lf|\n", counter, x, (a * x * x + b * x + c));
		}
		}
#endif
	stop
///////////////////////////////////////////////////////////////////
//Тема Указатели на функции
//Задание 5. Указатель на функцию. "Калькулятор".
#if 0
//Напишите функции:
//1)Sum - принимает два значения double и возвращает сумму
//этих значений
//2)Sub - принимает два значения double и возвращает разность
//этих значений
//3)Mul - *
//4)Div - /
//5)а для возведения в степень можете использовать функцию стандартной библиотеки
//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
//		вариантов этой функции, а Вам потребуется сформировать указатель на 
//		double pow(double, double);

//Предоставьте пользователю	следующую возможность:
//пока пользователь хочет пользоваться услугами Вашего калькулятора,
//он может вводить два значения и знак операции
//а Вы выводите результат. Результат получаете посредством вызова
//соответствующей Вашей функции по указателю.
//Предусмотрите возможность ввода непредусмотренного знака операции

	{
		double x = 0, y = 0;
		char operation = 0;
		bool cContinue = true;

		while (cContinue == true) {
			std::cout << "Enter first number: ";
			std::cin >> x;
			std::cout << "Enter second number: ";
			std::cin >> y;
			std::cout << "Enter operator: ";
			std::cin >> operation;

			double(*function)(double, double) = nullptr;

			switch (operation) {
				case '+':
					function = sum;
					break;
				case '-':
					function = sub;
					break;
				case '*':
					function = mul;
					break;
				case '/':
					function = div;
					break;
				case '^':
					function = pow;
					break;
				default:
					break;
			}
			if (function) {
				std::cout << x << " " << operation << " " << y << " = " << function(x, y);
				std::wcout << std::endl;
			}

			char choice = 0;
			std::cout << "Continue using the calculator? [y/n]: ";
			std::cin >> choice;

			switch (choice) {
				case 'Y':
				case 'y':
					break;
				case 'N':
				case 'n':
					cContinue = false;
					break;
			}
		}
	}

#endif
	stop
///////////////////////////////////////////////////////////////////
//Задание 6. Указатель на функцию в качестве аргумента.
#if 0
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//6a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй

	srand(time(0));
	const int N = 10;
	int nAr[10]; //массив для сортировки

	for (size_t i = 0; i < N; i++)
	{
		nAr[i] = rand() % 100;
	}
	//Печать исходного массива
	for (size_t i = 0; i < N; i++)
	{
		std::cout << nAr[i] << " ";
	}
	std::cout << std::endl;

	//Вызов сортировки
	int nTotal = N; //количество элементов в массиве
	Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

	//Печать результатов сортировки
	for (size_t i = 0; i < N; i++)
	{
		std::cout << nAr[i] << " ";
	}

	std::cout << std::endl;

	if (CmpInt(reinterpret_cast<char*>(&nAr[0]), &nTotal) == 1) {
		std::cout << "The first element is greater than the second";
	}
	else if (CmpInt(reinterpret_cast<char*>(&nAr[0]), &nTotal) == -1) {
		std::cout << "The second element is greater than the first";
	}
	else {
		std::cout << "Elements are equal";

	}
	std::cout << std::endl;
	stop

	//Задание 6б. По аналогии с 6а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	std::cout << std::endl;

	{
		srand(time(0));
		const int N = 10;
		double nAr[10]; //массив для сортировки

		for (size_t i = 0; i < N; i++)
		{
			nAr[i] = rand() % 100 / 10.0;
		}
		//Печать исходного массива
		for (size_t i = 0; i < N; i++)
		{
			std::cout << nAr[i] << "  ";
		}
		std::cout << std::endl;

		//Вызов сортировки
		int nTotal = N; //количество элементов в массиве
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(double), SwapInt, CmpInt);

		//Печать результатов сортировки
		for (size_t i = 0; i < N; i++)
		{
			std::cout << nAr[i] << "  ";
		}

		std::cout << std::endl;

		if (CmpInt(reinterpret_cast<char*>(&nAr[0]), &nTotal) == 1) {
			std::cout << "The first element is greater than the second";
		}
		else if (CmpInt(reinterpret_cast<char*>(&nAr[0]), &nTotal) == -1) {
			std::cout << "The second element is greater than the first";
		}
		else {
			std::cout << "Elements are equal";

		}
	}
	stop
	/*
	//Задание 6в*. По аналогии с 6а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort
	//для сортировки массива указателей на строки.

	const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En",. . . };

	//Замечание:

	//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива,
		Sort(reinterpret_cast<char*>(&arStr[0])), nTotal, sizeof(???), SwapStr, CmpStr);
	*/

#endif
	stop
///////////////////////////////////////////////////////////////////
//Задание 7. Массивы указателей на функцию.
#if 0
	//Напишите несколько функций вида
	//const char* GetString1();   
	//const char* GetString2();
	//const char* GetString3();
	//const char* GetString4();
	//const char* GetString5();

	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)

	// Вам предоставлен код этих функций. 
	//Подумайте:
	//1) все ли они корректны, если нет, то как исправить некорректность
	//2) может быть требуются какие-то дополнительные действия

	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
	//Введите номер функции, которую Вы хотите вызвать:
	int n;
	const char* arr[] = { GetString1(), GetString2(), GetString3(), GetString4(), GetString5()};

	/*for (size_t i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		std::cout << *arr << std::endl;
	}*/
	n = 1;
	

	//Вызовите функцию



	//Распечатайте результат
#endif
	stop
////////////////////////////////////////////////////////////////////////////
//Задание 8*.
#if 0
//Создайте одномерный массив (размерность вычисляется в процессе
//выполнения программы), заполните его значениями.
//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
//что такого значения в массиве еще нет. 
//Подсказка: при этом размер  массива должен увеличиться!
//Для проверки напишите функцию, которая выводит значения всех элементов на экран
#endif
///////////////////////////////////////////////////////////////////////////
//*********************   Дополнительное задание   ****************************************************
//Задание 9 (*)
// Выполните задание 8 по курсовой работе
// описание задания находится в файле "Задание (игра Змейка)_8 (двумерный динамический массив поля)_3.docx" 
//*****************************************************************************************************
return 0;
}//main
