
/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции

*************************************************************/
#include <iostream>
#include <tchar.h>
#include <cstdio>
#include <cstdarg>
#include "other.h"
#pragma warning(disable : 4996)

#define	  stop __asm nop
				
int _tmain()
{
//Задание 1. 
<<<<<<< HEAD
//массивы в качестве аргументов функции.
=======
//Массивы в качестве аргументов функции.
>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e
#if 0
//Напишите два варианта функции печати элементов
//1. Встроенного двумерного массива
//int ar[N][M]; //подумайте - как и где должны быть заданы N и M
//Замечание:
// Задать значения элементам массива можно либо с помощью списка инициализации, 
// либо с помощью кода 
//Вызов функции PrintArray может выглядеть так:
//	PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);  //Важно! первый параметр - имя двумерного (!) массива
	{
<<<<<<< HEAD
		const int N = 3, M = 4;
		int arr[N][M];

		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << "Enter element of index: [" << i << "][" << j << "]: ";
				std::cin >> arr[i][j];
			}
		}

		std::cout << std::endl;
=======
		const int N = 2, M = 2;
		int arr[N][M];

>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
<<<<<<< HEAD
				std::cout << arr[i][j] << " ";
			}
		}
	}
	//PrintArray(arr, N, M);
=======
				std::cout << "Enter array element for index [" << i << "][" << j << "]: ";
				std::cin >> arr[i][j];
			}
		}
>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e

		/*PrintArray(arr, N, M);*/
	}
//2. динамического двумерного массива (обе размерности вычисляются)
//Замечание:
<<<<<<< HEAD
//Задать значения элементам массива можно с помощью кода 
	{
		int N = 0, M = 0;

		std::cout << "Enter array rows size: ";
		std::cin >> N;
		std::cout << "Enter array columns size: ";
		std::cin >> M;

		int** arr = new int* [N];

		for (size_t i = 0; i < N; i++)
		{
			arr[i] = new int[M];
		}

=======
// Задать значения элементам массива можно с помощью кода
	{
		int N = 2, M = 2; //2 строчки, а в каждой строчке по 2 колонки
		
		int** arr = new int* [N]; //создали массив указателей

		for (size_t i = 0; i < N; i++)
		{
			arr[i] = new int[M]; //в каждый элемент, который будет хранить указатель, присваиваем новый динамический массив
		}

		//Заполняем массив
>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
<<<<<<< HEAD
				std::cout << "Enter element of index: [" << i << "][" << j << "]: ";
=======
				std::cout << "Enter array element for index [" << i << "][" << j << "]: ";
>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e
				std::cin >> arr[i][j];
			}
		}

<<<<<<< HEAD
		std::cout << std::endl;
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << arr[i][j] << " ";
			}
		}
=======
		PrintArray(arr, N, M);
>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e

		for (size_t i = 0; i < N; i++)
		{
			delete[] arr[i];
		}

		delete[] arr;
	}
#endif
	stop
/////////////////////////////////////////////////////////////////////////////
//Задание 2. 
//Передача имени встроенного двумерного массива в качестве параметра функции.
#if 0
//Напишите две взаимодополняющие друг друга функции:
//1.  ... DayOfYear(...)
//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
//в порядковый день года(возвращаемое значение)
//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
// (принимает год и порядковый день года в качестве параметров и должна сформировать
// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
//данные приведенного ниже двухмерного массива nDayTab
//Проверьте работоспособность обеих функций с помощью следующего фрагмента:
//Вызов функции DayOfYear может выглядеть так:

int nDayTab[2][12] = {
	{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
	{31,29,31,30,31,30,31,31,30,31,30,31} }; //високосный год

	int day, month, year;

	std::cout << "Enter day: ";
	std::cin >> day;
	std::cout << "Enter month: ";
	std::cin >> month;
	std::cout << "Enter year: ";
	std::cin >> year;

	int dayOfYear = DayOfYear(day, month, year, nDayTab);

	if (dayOfYear == -1) {
		std::cout << std::endl;
		std::cout << "Invalid date entry!" << std::endl;
	}
	else {
		std::cout << std::endl;
		std::cout << "The " << day << "." << month << "." << year << " is the " << dayOfYear << " day of the year." << std::endl;
	}

	//size_t day = ..., month = ..., year = ...;
	//size_t numDay = DayOfYear(day, month, year, nDayTab);  //Важно! последний параметр- имя двумерного (!) массива


//Проверка результата обратной функцией DayOfMonth        //Важно! последний параметр- имя двумерного (!) массива
//...
#endif
	stop
/////////////////////////////////////////////////////////////////////////////
//Задание 3.
#if 0
	{
		//Задание 3а. Функции с переменным числом параметров.
		//Напишите функцию (дана заготовка VarArgs, не использующая
		// макросы), которая принимает переменное число аргументов
		// типа int и выводит на печать число принятых параметров и
		// их значения.
		// Признаком конца списка является нулевое значение.

		int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
		VarArgs(nN1, 0);
		VarArgs(nN1, nN2, 0);
		VarArgs(nN1, nN2, nN3, nN4, nN5, 0);

		std::cout << std::endl;
		//Задание 3б. Модифицируйте функцию 3а с помощью макросов
		// va_start, va_arg, va_end

<<<<<<< HEAD
		//Задание 3б. Модифицируйте функцию 3а с помощью макросов
		// va_start, va_arg, va_end
=======
		VarArgsMacros(nN1, 0);
		VarArgsMacros(nN1, nN2, 0);
		VarArgsMacros(nN1, nN2, nN3, nN4, nN5, 0);
		stop
	}
>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e
#endif
	stop
///////////////////////////////////////////////////////////////////
//Тема "Старые" потоковые функции стандартной библиотеки
<<<<<<< HEAD
//Задание 4.1
#if 1
//С помощью функции scanf сформирйуте три коэффициента : A, B, C
	{
		int a, b, c;
		
		printf("Enter integers: ");
		printf("A: ");
		scanf("%d", &a);
		printf("B: ");
		scanf("%d", &b);
		printf("C: ");
		scanf("%d", &c);
		printf("A = %d, B = %d, C = %d", a, b, c);
	}
#endif
	stop
//Задание 4.2.
=======
//Задание 4.1-4.2
>>>>>>> ec376debb4b10a3905f2d8d961e53cd5d3ac657e
#if 0
//С помощью функции scanf сформируйте три коэффициента : A, B, C
	{
		int a, b, c;

		std::cout << "Enter integer for A: ";
		scanf("%i", &a);
		std::cout << "Enter integer for B: ";
		scanf("%i", &b);
		std::cout << "Enter integer for C: ";
		scanf("%i", &c);
		std::cout << std::endl;
		std::cout << "A = " << a << "\nB = " << b << "\nC = " << c << std::endl;
		std::cout << std::endl;

//Выведите таблицу значений y = A * x * x + B * x + C
//при изменении x в диапазоне -2 до +2 с шагом 0.5

		int counter = 0;
		for (double x = -2.01; x < 2.0; x += 0.5) {
			counter++;
			printf("| %2d|%4.1lf|  %6.1lf|\n", counter, x, (a * x * x + b * x + c));
		}
	}
#endif
	stop
///////////////////////////////////////////////////////////////////
//Тема Указатели на функции
//Задание 5. Указатель на функцию. "Калькулятор".
#if 0
//Напишите функции:
//1)Sum - принимает два значения double и возвращает сумму
//этих значений
//2)Sub- принимает два значения double и возвращает разность
//этих значений
//3)Mul - *
//4)Div - /
//5)а для возведения в степень можете использовать функцию стандартной библиотеки
//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
//		вариантов этой функции, а Вам потребуется сформировать указатель на 
//		double pow(double, double);

//Предоставьте пользователю	следующую возможность:
//пока пользователь хочет пользоваться услугами Вашего калькулятора,
//он может вводить два значения и знак операции
//а Вы выводите результат. Результат получаете посредством вызова
//соответствующей Вашей функции по указателю.
//Предусмотрите возможность ввода непредусмотренного знака операции
#endif
	stop
///////////////////////////////////////////////////////////////////
//Задание 6. Указатель на функцию в качестве аргумента.
#if 0
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//6a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй
	/*
		int nAr[]=...	//массив для сортировки

		//Печать исходного массива

		//Вызов сортировки
		int nTotal=...			//количество элементов в массиве
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки

		stop
	*/
	/*
	//Задание 6б. По аналогии с 6а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	*/

	/*
	//Задание 6в*. По аналогии с 6а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort
	//для сортировки массива указателей на строки.

	const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En",. . . };

	//Замечание:

	//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива,
		Sort(reinterpret_cast<char*>(&arStr[0])), nTotal, sizeof(???), SwapStr, CmpStr);
	*/

#endif
	stop
///////////////////////////////////////////////////////////////////
//Задание 7. Массивы указателей на функцию.
#if 1
	//Напишите несколько функций вида
	//const char* GetString1();   
	//const char* GetString2();
	//const char* GetString3();
	//const char* GetString4();
	//const char* GetString5();

	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)

	// Вам предоставлен код этих функций. 
	//Подумайте:
	//1) все ли они корректны, если нет, то как исправить некорректность
	//2) может быть требуются какие-то дополнительные действия

	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
	//Введите номер функции, которую Вы хотите вызвать:
		int n;



	//Вызовите функцию



	//Распечатайте результат
#endif
	stop
////////////////////////////////////////////////////////////////////////////
//Задание 8*.
#if 0
//Создайте одномерный массив (размерность вычисляется в процессе
//выполнения программы), заполните его значениями.
//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
//что такого значения в массиве еще нет. 
//Подсказка: при этом размер  массива должен увеличиться!
//Для проверки напишите функцию, которая выводит значения всех элементов на экран
#endif
///////////////////////////////////////////////////////////////////////////
//*********************   Дополнительное задание   ****************************************************
//Задание 9 (*)
// Выполните задание 8 по курсовой работе
// описание задания находится в файле "Задание (игра Змейка)_8 (двумерный динамический массив поля)_3.docx" 
//*****************************************************************************************************
	return 0;
}//main

