/*************************************************************
	Практическое занятие 1. Встроенные многомерные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/

#define	  stop __asm nop

#include <iostream>
#include <string.h>
#include <cstdlib>

int main()
{
/////////////////////////////////////////////////////////////////
//			Встроенные  многомерные массивы                   //
///////////////////////////////////////////////////////////////
//Задание 1.
#if 0
//A
	{
		//Объявите трехмерный N*M*K массив и сформируйте указанные
		//значения элементов следующим образом:
		//(проинициализируйте массив при определении)
		// 
		//						  |------------|
		//  					/ |	5  5  5  5 |
		//					   |------------|5 |
		//  				 / | 4  4  4  4 |5 |
		//				    |------------|4 |__|
		//			      / | 3  3  3  3 |4 |/
		//    			 |------------|3 |__|
		//			   / | 2  2  2  2 |3 | /
		//			  |------------|2 |__|
		//			  | 1  1  1  1 |2 | /
		//			  | 1  1  1  1 |__|
		//			  | 1  1  1  1 | /
		//			  |____________|

		const int N = 5, M = 3, K = 4;
		int arr[N][M][K] = 
		{ 
			{ {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1} },
			{ {2, 2, 2, 2}, {2, 2, 2, 2}, {2, 2, 2, 2} },
			{ {3, 3, 3, 3}, {3, 3, 3, 3}, {3, 3, 3, 3} },
			{ {4, 4, 4, 4}, {4, 4, 4, 4}, {4, 4, 4, 4} },
			{ {5, 5, 5, 5}, {5, 5, 5, 5}, {5, 5, 5, 5} }
		};
	}
//Б
	{
		//Объявите трехмерный N*M*K неинициализированный массив, 
		// присвойте значения элементам с помощью кода
		// 
		//						  |------------|
		//  					/ |	5  5  5  5 |
		//					   |------------|5 |
		//  				 / | 4  4  4  4 |5 |
		//				    |------------|4 |__|
		//			      / | 3  3  3  3 |4 |/
		//    			 |------------|3 |__|
		//			   / | 2  2  2  2 |3 | /
		//			  |------------|2 |__|
		//			  | 1  1  1  1 |2 | /
		//			  | 1  1  1  1 |__|
		//			  | 1  1  1  1 | /
		//			  |____________|

		//Рекомендация: В качестве размерностей массива лучше указать N, M, K,
		//а не задавать их жестко.

		//Средствами отладчика проверьте правильность Вашего решения.

		//Или выведите содержимое массива на печать.
		//Удобно выводить построчно каждый слой  массива и
		//после каждого слоя пропускать строку для того, чтобы отделить один слой от другого

		const int N = 5, M = 3, K = 4;
		int arr[N][M][K];
		int count = 0;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				for (int s = 0; s < K; s++)
				{
					arr[i][j][s] = i + 1;
				}
			}
			count++;
		}
	}
//В
	{
		//Найдите сумму элементов массива, объявленного в пункте б) 
		//Подумайте, как это сделать эффективно.

		const int N = 5, M = 3, K = 4;
		int arr[N][M][K];
		int sum = 0;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				for (int s = 0; s < K; s++)
				{
					sum += arr[i][j][s];
				}
			}
		}
		std::cout << "Sum: " << sum << std::endl;
	}
//Г
	{
		//Объявите трехмерный N*M*K массив и проинициализируйте его при определении:
		//				     |--------|
		//			       / |3  0  0 |
		//      		 |---------|0 |
		//    		   / | 2  0  0 |0 |
		//			  |---------|0 |__|
		//			  | 1  0  0 |0 | /
		//			  | 0  0  0 |__|
		//			  | 0  0  0 | /
		//			  |_________|

		const int N = 3, M = 3, K = 3;
		int arr[N][M][K] =
		{
			{{1}},
			{{2}},
			{{3}}
		};
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				for (int s = 0; s < K; s++)
				{
					std::cout << arr[i][j][s] << ' ';
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
	}
	stop
//Д
	{
		//Инициализация массивов строковыми литералами:
		//Объявите и проинициализируйте строковыми литералами два массива:
		//двумерный массив символов и одномерный массив указателей на char. 
		//Поясните разницу в использовании элементов таких массивов.

		const int N = 2, K = 7;
		char arr_str[N][K] = { { "qwerty" }, { "hansel" } };
		const char* arr_p[] = { { "qwerty" }, { "hansel" } }; //Не можем изменить значение, т.к. ук. на конст.значение
		arr_str[1][1] = 'W';
		char tmp = arr_str[1][1];
		tmp = arr_p[1][2];
		//arr_p[1][2] = 'W';
	}
#endif
/////////////////////////////////////////////////////////////////////
//Задание 2.
#if 0
	//С помощью данной заготовки напишите программу,которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 10*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение всего массива (больше свободных строк нет);

	//То есть:
		//a) можно заполнять весь массив полностью (не забудьте подсказать, сколько элементов в массиве)
		//б) можно заполнять массив частично, до тех пор, пока пользователь не ввел строку "*".
		//Например:вводим строки (строки с пробелами не задаются, т.к. пробелы являются разделителями):
		//"Hello"
		//"Ok"
		//"*"
	//Выполните сортировку строк в алфавитном порядке. 
	// 
	//Пояснение: крайне не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти ( в нашем случае перемещать (копировать) строки)
	//Намного эффективнее завести массив указателей на соответствующие строки 
	//и перемещать только указатели на начало строк (массивов символов).
	//Вопрос: При таком способе что будет  отсортировано?

	//Подсказка: для лексикографического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string.h>.

	//int strcmp(char const* _Str1, char const* _Str2);

	// далее Вам предлагается алгоритм, следуя которому, Вы сможете решить задачу.
	{

		//Определите необходимые значения как константы
		//STOP_STRING  -  "*"	//признак "прекратить ввод"
		//M  -  80	//максимальный размер одной строки
		//N  -  10	//максимальное количество строк в массиве
		const char* STOP_STRING = "*";
		const int N = 10, M = 80;

		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M
		char cBuffer[N][M];

		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N
		char* cPointers[N];

		//A:
		//Цикл ввода строк:
		//а) выведите приглашение для ввода
		//б) пока не введена строка STOP_STRING или не заполнен весь массив
		//ввод строки в массив cBuffer:
		//если введена строка - признак окончания, то выйти из цикла

		//B:
		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer
		//Выдать диагностику о том, что прием строк завершен.
		//Распечатайте содержимое массива

		//C:
		//Теперь сортируем строки:
		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания кода первого символа
		//Распечатайте содержимое массива после сортировки

		//A:
		int counter = 0;

		for (int i = 0; i < N; i++)
		{
			std::cout << "Enter the string: ";
			std::cin >> cBuffer[i];
			if (strcmp(cBuffer[i], STOP_STRING) == 0) {
				break;
			}
			cPointers[i] = cBuffer[i];
			counter++;
		}

		std::cout << "A: " << std::endl;

		for (int i = 0; i < counter; i++)
		{
			std::cout << cPointers[i] << ' ';
		}
		std::cout << std::endl;

		//B:
		std::cout << "B: " << std::endl;

		int pCounter = 0;

		//for (int i = 0; i < N; i++)
		//{
		//	if (strcmp(cBuffer[i], STOP_STRING) != '\0') {
		//		cPointers[pCounter] = cBuffer[i];
		//		pCounter++;
		//	}
		//}

		//for (int i = 0; i < pCounter; i++)
		//{
		//	std::cout << cPointers[i] << ' ';
		//}
		//std::cout << std::endl;

		//C:
		std::cout << "C: " << std::endl;
		std::cout << "Sort: " << std::endl;

		for (int i = 0; i < counter; i++)
		{
			for (int j = 0; j < counter - 1; j++)
			{
				//if (*(cPointers[j + 1]) < *(cPointers[j])) 
				if(strcmp(cPointers[j+1],cPointers[j]) < 0)
				{
					char* temp = cPointers[j + 1];
					cPointers[j + 1] = cPointers[j];
					cPointers[j] = temp;
				}
			}
		}

		for (int i = 0; i < counter; i++)
		{
			std::cout << cPointers[i] << ' ';
		}
		std::cout << std::endl;

	}
#endif
	stop
/////////////////////////////////////////////////////////////////////
//Задание 3*. Объявление и использование указателей на многомерные массивы.
#if 0
	//Проинициализируйте трехмерный массив
	const int N = 4, M = 3, K = 4;
	double dArray[N][M][K]; //так, как показано на рисунке и напишите фрагмент
//  кода, который меняет местами значения элементов четных и нечетных слоев:
//
//	было:
// 
//					    |-----------|
//  				  / |4  4  4  4 |
//				     |-----------|4 |
//			       / |3  3  3  3 |4 |
//    			 |------------|3 |__|
//			   / | 2  2  2  2 |3 | /
//			  |------------|2 |__|
//			  | 1  1  1  1 |2 | /
//			  | 1  1  1  1 |__|
//			  | 1  1  1  1 | /
//			  |____________|

//	стало:	

//					   |------------|
//  				  /| 3  3  3  3 |
//				     |-----------|3 |
//			       / |4  4  4  4 |3 |
//    			 |------------|4 |__|
//			   / | 1  1  1  1 |4 | /
//			  |------------|1 |__|
//			  | 2  2  2  2 |1 | /
//			  | 2  2  2  2 |__|
//			  | 2  2  2  2 | /
//			  |____________|
// 
//for (int i = 0; i < ...; ...)
//{
//	//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
//	... = dArray[i];
//	... = dArray[i + 1];
//	//Подсказки:
//	//1) Слева от знака равенства надо определить два сложных указателя.
//	//Так как справа находятся "имена" слоев, т.е. двумерных массивов, то
//	//остается вспомнить какой указатель является эквивалентным для имени двумерного массива.
//
//	//2)дальше, воспользовавшись этими указателями, переставляем местами элементы i-того и i+1-ого слоев
//
//
//}

	int count = 0;

	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			for (int s = 0; s < K; s++)
			{
				dArray[i][j][s] = i + 1;
			}
		}
		count++;
	}

	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			double (*p)[K] = dArray[i];
			double (*q)[K] = dArray[i + 1];

			for (int k = 0; k < K; k++)
			{
				double temp = p[j][k];
				p[j][k] = q[j][k];
				q[j][k] = temp;
			}
		}
	}
#endif	
///////////////////////////////////////////////////////////////////////////
//Задание 4
#if 0
	{
		//а) Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
		const int N = 5, M = 10;
		char arr[N][M];
		//Сформируйте значения элементов массива с помощью генератора случайных
		//чисел таким образом, чтобы в массиве были только символы '_' и '*'

		//Подсказка 1: для генерации случайных чисел используйте функцию
		//стандартной библиотеки - rand() (<cstdlib>)
		//Можно с помощью генератора случайных чисел  и оператора % получать значения 0 и 1,
		// а в массив помещать соответственно '_' и '*'.

		//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
		//чисел являются "псевдослучайными", то есть при двух последовательных запусках
		//приложения Вы получаете две одинаковые последовательности значений.
		//Для того чтобы генерируемые "случайные" значения были разными при каждом
		//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
		//и time() (<ctime>).
		//Функция srand() осуществляет "привязку" начала генерации к указанному в качестве параметра значению.
		//Функция time() задает эту точку отсчета, считывая текущее время
		//srand( time( 0 ) );

		//Замечание: в программе запускать функцию srand()  достаточно один раз

		std::cout << "A: " << std::endl;
		std::cout << std::endl;

		srand(time(0));

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				int temp = rand() % 2;

				if (temp == 0) {
					arr[i][j] = '*';
				}
				else if (temp == 1) {
					arr[i][j] = '_';
				}

			}
		}

		for (size_t i = 0; i < N; i++)
		{
			for (size_t J = 0; J < M; J++)
			{
				std::cout << arr[i][J];
			}

			std::cout << std::endl;
		}
		std::cout << std::endl;

		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
		//и распечатайте массив по строкам - "постройте распределение"

		for (size_t i = 0; i < N; i++)
		{
			char left = 0;
			char right = M - 1;

			while (left < right)
			{
				if (arr[i][left] == '_')
				{
					if (arr[i][right] == '*')
					{
						char temp = arr[i][left];
						arr[i][left] = arr[i][right];
						arr[i][right] = temp;
						left++;
						right--;
					}
					else
					{
						right--;
					}
				}
				else
				{
					left++;
				}
			}
		}

		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << arr[i][j];
			}

			std::cout << std::endl;
		}

		std::cout << std::endl;

		// б) Модифицируйте предыдущее задание следующим способом:
		//После заполнения массива с помощью генератора случайных чисел
		//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
		//"распределение"

		std::cout << "B: " << std::endl;
		std::cout << std::endl;

		for (int i = 0; i < N - 1; i++) {
			for (int j = 0; j < M; j++) {
				if (arr[i][j] == '*') {
					arr[i][j] = '_';
					arr[i + 1][j] = '*';
				}
			}
		}

		//for (size_t i = 0; i < N - 1; i++)
		//{
		//	char left = 0;
		//	char right = M;

		//	while (left < right)
		//	{
		//		if (arr[i][left] == '_')
		//		{
		//			if (arr[i][right] == '*')
		//			{
		//				char temp = arr[i][left];
		//				arr[i][left] = arr[i][right];
		//				arr[i][right] = temp;
		//				left++;
		//				right--;
		//			}
		//			else
		//			{
		//				right--;
		//			}
		//		}
		//		else
		//		{
		//			left++;
		//		}
		//	}
		//}

		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << arr[i][j];
			}

			std::cout << std::endl;
		}
	}
#endif	
/////////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                     //
///////////////////////////////////////////////////////////////
//Задание 5.
#if 0
	{
		////Задание 5а.Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов с помощью генератора случайных чисел.

		srand(time(0));

		const int N = 5, M = 5;

		int** p = new int* [N]; //выделение памяти для одномерного массива

		for (size_t i = 0; i < N; i++)
		{
			p[i] = new int[M];
		}

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				p[i][j] = rand() % 100;
			}
		}

		std::cout << "5A:" << std::endl;
		std::cout << std::endl;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << p[i][j] << " ";
			}
			std::cout << std::endl;
		}

		std::cout << std::endl;

		//Задание 5б. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"

		for (int row = 0; row < N; row++)
		{
			for (int j = 0; j < M - 1; j++)
			{
				int indexMax = j;

				for (int k = j + 1; k < M; k++)
				{
					if (p[row][k] > p[row][indexMax]) {
						indexMax = k;
					}
				}

				int temp = p[row][j];
				p[row][j] = p[row][indexMax];
				p[row][indexMax] = temp;
			}
		}

		std::cout << "5B:" << std::endl;
		std::cout << std::endl;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << p[i][j] << " ";
			}
			std::cout << std::endl;
		}

		std::cout << std::endl;

		//Задание 5в. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива  
		//равным среднему значению элементов i-ой строки
		//двухмерного массива

		int* pn = new int[N];

		for (int i = 0; i < N; i++)
		{
			pn[i] = 0;

			for (int j = 0; j < M; j++)
			{
				pn[i] += p[i][j];
			}

			pn[i] /= M;
		}

		std::cout << "5C:" << std::endl;
		std::cout << std::endl;

		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << pn[i] << " ";
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;

		//Подсказка - не забудьте освободить память!

		delete[] pn;
		delete[] p;
	}
#endif
/////////////////////////////////////////////////////////////////////////////
//Задание 6.
#if 1
		//Реализуйте задание 2, используя не встроенные, а ДИНАМИЧЕСКИЕ массивы (массив?).
		// Важно! 
		//Так как строки могут быть разной длины, /эффективным решением было бы 
		//отводить под каждую строку ровно столько байтов, сколько требуется для ее хранения.
		//Для того, чтобы определить длину введенной строки можно воспользоваться 
		//функцией strlen 
		//size_t strlen(char const* _Str);

		//При этом значение количества строк сформируйте с помощью потока ввода

	//Цикл ввода строк:

	// Для ввода строки нужно использовать буфер "достаточного" размера. 
	// В качестве такого буфера обычно используется встроенный массив.
	// Для того, чтобы введенную строку  скопировать из буфера в массив  строк,
	// можно воспользоваться функцией strcpy
	//char* strcpy(	char* _Dest,  char const* _Source);
	//  или
	// 
	//errno_t strcpy_s(char* _Dest, size_t  _SizeInBytes, char const* _Source); 
	//где _SizeInBytes - размер "приемного" буфера _Dest

	//Замечание: 
	//скорее всего,если Вы используете strcpy, то при компиляции Вы получите следующую ошибку:
	//Severity	Code	Description	Project	File	Line	Suppression State
	//	Error	C4996	'strcpy': This function or variable may be unsafe.
	//Consider using strcpy_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.

	//Это происходит потому, что функция strcpy считается небезопасной.

	//Для того, чтобы пользоваться функцией strcpy, а не strcpy_s, можно
	//  - либо объявить макрос #define _CRT_SECURE_NO_WARNINGS   (обязательно ДО всех #include !!!!!)
	//- либо установить режим без доп. проверки на безопасность Properties->C/C++ ->General->SDL checs -> No
	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа
	//Освобождение занятой памяти

	int nStringNumber;

	std::cout << "Enter number of strings: ";
	std::cin >> nStringNumber;




#endif
//*********************   Дополнительное задание   ****************************************************
//Задание 7 (*)  
// Выполните задание 7 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_7 (двумерный встроенный массив поля)_3.docx" 
//*****************************************************************************************************


	return 0;
}

